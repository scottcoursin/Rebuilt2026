package frc.robot.subsystems;

import java.util.Optional;

import edu.wpi.first.util.datalog.DataLog;
import edu.wpi.first.util.datalog.DoubleLogEntry;

import com.ctre.phoenix6.signals.AnimationDirectionValue;
import com.ctre.phoenix6.signals.RGBWColor;
import com.ctre.phoenix6.signals.StripTypeValue;
import com.ctre.phoenix6.signals.LarsonBounceValue;
import com.ctre.phoenix6.hardware.CANdle;
import com.ctre.phoenix6.configs.CANdleConfiguration;
import com.ctre.phoenix6.configs.LEDConfigs;
import com.ctre.phoenix6.controls.SolidColor;
import com.ctre.phoenix6.controls.ColorFlowAnimation;
import com.ctre.phoenix6.controls.EmptyAnimation;
import com.ctre.phoenix6.controls.FireAnimation;
import com.ctre.phoenix6.controls.SingleFadeAnimation;
import com.ctre.phoenix6.controls.StrobeAnimation;
import com.ctre.phoenix6.controls.LarsonAnimation;
import com.ctre.phoenix6.controls.RainbowAnimation;
import com.ctre.phoenix6.controls.RgbFadeAnimation;
import com.ctre.phoenix6.controls.TwinkleAnimation;
import com.ctre.phoenix6.controls.TwinkleOffAnimation;

import edu.wpi.first.wpilibj2.command.Subsystem;

import edu.wpi.first.wpilibj.DataLogManager;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.DriverStation;

public class LED implements Subsystem {

    // These are public constant colors to be used by any command or subsystem
    // Add more if needed
    //                                                              red     green       blue        white
    public static final RGBWColor c_colorPink   = new RGBWColor(  80,  10,  15,   0 );
    public static final RGBWColor c_colorGreen  = new RGBWColor(  13,  80,   0,   0 );
    public static final RGBWColor c_colorBlue   = new RGBWColor(   0,   0, 255,   0 );
    public static final RGBWColor c_colorRed    = new RGBWColor( 255,   0,   0,   0 );
    public static final RGBWColor c_colorOrange = new RGBWColor(  43,   6,   0, 255 );
    public static final RGBWColor c_colorYellow = new RGBWColor( 255,   0,   0,   0 );
    public static final RGBWColor c_colorPurple = new RGBWColor(  80,   0,  80,   0 );
    public static final RGBWColor c_colorBlack  = new RGBWColor(   0,   0,   0,   0 );
    public static final RGBWColor c_colorWhite  = new RGBWColor( 255, 255, 255,  10 );

    // Default color is typically used during idle, use getDefaultColor/setDefaultColor
    private static RGBWColor c_defaultColor = c_colorWhite;

    /**
     * LED subsystem constructor
     */
    public LED() {
        // Create a local logging object to pass into the DoubleLogEntry
        DataLog log = DataLogManager.getLog();

        // Create the LED config object
        LEDConfigs ledConfigs = new LEDConfigs();
        // Configure strip type (may change) and brightness
        // TODO: Check that the current LED strip is RGB and not RGBW, BGR, etc.
        ledConfigs = ledConfigs.withStripType(StripTypeValue.RGB).withBrightnessScalar(1.0);
        m_candleConfig.withLED(ledConfigs);
        // Apply the configurations to the CANdle itself
        m_candle.getConfigurator().apply(m_candleConfig);

        m_speed = c_defaultSpeed;

        // Setting up each of the animations variables (speed, direction, etc.)
        // TODO: if they have a weird speed or animation, change the setup here
        m_colorFlowAnimation = m_colorFlowAnimation.withDirection(AnimationDirectionValue.Forward).withFrameRate(m_speed);
        m_larsonAnimation = m_larsonAnimation.withBounceMode(LarsonBounceValue.Front).withFrameRate(m_speed).withSize(3);
        m_singleFadeAnimation = m_singleFadeAnimation.withFrameRate(m_speed);
        m_strobeAnimation = m_strobeAnimation.withFrameRate(m_speed);
        m_twinkleAnimation = m_twinkleAnimation.withFrameRate(m_speed);
        m_twinkleOffAnimation = m_twinkleOffAnimation.withFrameRate(m_speed);
        m_rainbowAnimation = m_rainbowAnimation.withDirection(AnimationDirectionValue.Forward).withFrameRate(m_speed);
        m_rgbFadeAnimation = m_rgbFadeAnimation.withFrameRate(m_speed);
        m_fireAnimation = m_fireAnimation.withDirection(AnimationDirectionValue.Forward).withFrameRate(m_speed);

        // Upon robot initialization, we want to clear the animation slot
        setAnimation(getDefaultColor(), EAnimation.kBlank);
        // The above line is equivalent to:
        //      setColor(c_defaultColor);
        //      m_candle.setControl(m_emptyAnimation);

        // Set the robot to orange before it's enabled (same as RSL)
        setAnimation(c_colorOrange, EAnimation.kSolid);

        m_log = new DoubleLogEntry(log, "/subsystem/led");

        // Original C++ code:
        //  /*ctre::phoenix::ErrorCode error =*/ m_candle.GetLastError(); // gets the last error generated by the CANdle

        // CANdleFaults faults;
        // /*ctre::phoenix::ErrorCode faultsError =*/ m_candle.GetFaults(faults); // fills faults with the current CANdle faults; returns the last error generated

        // printf("candle error: %d", error);
        // printf("candle fault: %d", faultsError);
        m_candle.getFaultField();
        m_candle.getStickyFaultField();
    }

    @Override
    public void periodic() {
        // Should set the alliance once we know it
        if (!m_bAllianceSet){
            m_bAllianceSet = true;
            m_alliance = DriverStation.getAlliance();
        }
        
        boolean robotEnabled = SmartDashboard.getBoolean("Robot Enabled", false);

        if (robotEnabled) {
            // Whenever the robot isn't busy (isn't doing an action that needs the LEDs)
            if (!isRobotBusy()) {
                // In these cases, we use our idle animation
                // The idle animation can be ANYTHING (here it's a solid default color)
                setAnimation(getDefaultColor(), EAnimation.kSolid);
            } // If it IS busy, the colors/animation are handled by commands

        } else {
            // Robot is disabled, set LEDs to alliance color
            if (m_alliance.get() == DriverStation.Alliance.Blue) {
                // Should only change the color when our current color is wrong
                if (!isSameColor(m_currentColor, c_colorBlue))
                    // Flow animation alliance color (blue)
                    setAnimation(c_colorBlue, EAnimation.kFlow);

            } else if (!isSameColor(m_currentColor, c_colorRed)) {
                // Flow animation alliance color (red)
                setAnimation(c_colorRed, EAnimation.kFlow);
            }
        }
        // m_log.Append(add_data_here);
    }

    /**
     * The EAnimation enum contains a number for each animation we might want
     * to set the LEDs to. The default is solid color, and we can add as many as we
     * want. These represent a particular combination of RGBW and phoenix6 Animation
     * Request, usually the color is specified by the method call. If we want a
     * faster strobe and slower strobe (etc), we can make them two different values in
     * the enum.
     * 
     * Each command can choose which animation it wants to set the LEDs to, along
     * with a constant color pulled statically from the LED class.
     */
    public enum EAnimation {
    // Can be amended to include as many different animations as desired
        kDefaultAnim(0),
        kSolid(0),
        kFade(1),
        kFlow(2),
        kStrobe(3),
        kScanner(4),
        kTwinkle(5),
        kTwinkleOff(6),
        kRainbow(7),
        kRGBFade(8),
        kFire(9),
        kBlank(10); 

        // The corresponding enumeration value of the object
        private int value;

        // The constructor to set the enumeration value of the object
        private EAnimation(int value) {
            this.value = value;
        }

        // Returns the internal value of the object (is this even necessary?)
        public int getValue() {
            return this.value;
        }
    }

    /**
     * The ECurrentAction enum is used by the ENTIRE robot code, wherever the robot
     * desires to control the LED subsystem. It is used externally to tell the LEDs what
     * the robot is currently doing, and it is up to the programmer to determine
     * which robot actions take precedence. We can fetch the current action externally,
     * and if it's too important to change the LED action, we may choose not to.
     * 
     * This is mostly used by the LED subsystem to determine if the robot is busy,
     * but it allows specific control over the LEDs in more cases.
     */
    public enum ECurrentAction {
    // Can be amended to include as many different actions as desired
        kDefaultAction(0),
        kIdle(0),
        kIntaking(1),
        kPreShoot(2),
        kShootMovement(3),
        kShoot(4),
        // Add whichever actions the robot does during the match, initialize with value
        kClimbing(8),
        kClimbFinish(9);

        // The corresponding enumeration value of the object
        private int value;

        // The constructor to set the enumeration value of the object
        private ECurrentAction(int value) {
            this.value = value;
        }

        // Returns the internal value of the object (is this even necessary?)
        public int getValue() {
            return this.value;
        }
    }

    /**
     * setAnimation sets the CANdle to a particular state
     * 
     * @param rgbw the color we want to set the animation to
     * @param animate the animation we want to set the LEDs to (including solid and blank)
     */
    public void setAnimation(RGBWColor rgbw, EAnimation animate) {
        // Branch our code depending on which animation was selected
        switch (animate) {
            // If solid:
            case kSolid:
                // Set the m_currentColor with a method call
                setColor(rgbw);
                // UPDATE our member variable solid color to be with this new color
                m_solidColor = m_solidColor.withColor(rgbw);
                // Set the animation on the candle to be the color-updated animation
                m_candle.setControl(m_solidColor);
                // Break (exit the switch-case)
                break;
            // Do the same for each and every animation
            case kFade:
                setColor(rgbw);
                m_singleFadeAnimation = m_singleFadeAnimation.withColor(rgbw);
                m_candle.setControl(m_singleFadeAnimation);
                break;

            case kFlow:
                setColor(rgbw);
                m_colorFlowAnimation = m_colorFlowAnimation.withColor(rgbw);
                m_candle.setControl(m_colorFlowAnimation);
                break;

            case kStrobe:
                setColor(rgbw);
                m_strobeAnimation = m_strobeAnimation.withColor(rgbw);
                m_candle.setControl(m_strobeAnimation);
                break;
            
            case kScanner:
                setColor(rgbw);
                m_larsonAnimation = m_larsonAnimation.withColor(rgbw);
                m_candle.setControl(m_larsonAnimation);
                break;

            case kTwinkle:
                setColor(rgbw);
                m_twinkleAnimation = m_twinkleAnimation.withColor(rgbw);
                m_candle.setControl(m_twinkleAnimation);
                break;

            case kTwinkleOff:
                setColor(rgbw);
                m_twinkleOffAnimation = m_twinkleOffAnimation.withColor(rgbw);
                m_candle.setControl(m_twinkleOffAnimation);
                break;

            case kRainbow:
                setColor(rgbw);
                m_candle.setControl(m_rainbowAnimation);
                break;

            case kRGBFade:
                setColor(rgbw);
                m_candle.setControl(m_rgbFadeAnimation);
                break;

            case kFire:
                setColor(rgbw);
                m_candle.setControl(m_fireAnimation);
                break;

            // Default case (blank)
            default:
                // We will still set the color
                setColor(rgbw);
                // Empty animation clears the LED animation
                m_candle.setControl(m_emptyAnimation);
                break;
        }
    }

    /**
     * returns true if color/animation are handled in periodic, false if being handled
     * in a command somewhere
     */
    public boolean isRobotBusy() { return m_currentAction != ECurrentAction.kIdle; }
    // public void SetRobotBusy(boolean value) { m_busy = value; }

    // Sets a new default color for the LED subsystem
    public void setDefaultColor(RGBWColor color) { m_defaultColor = color; }
    // Retrieves our default color
    public RGBWColor getDefaultColor() { return m_defaultColor; }

    // Set the current action, used inside and outside (by commands)
    public void setCurrentAction(ECurrentAction action) { m_currentAction = action; }
    // Retrieves the current action, used inside and outside (by commands)
    public ECurrentAction getCurrentAction() { return m_currentAction; }

    private CANdleConfiguration m_candleConfig;
    private DoubleLogEntry m_log;
    private CANdle m_candle = new CANdle(1); // TODO: new CANdle(kLEDCANID);
    private Optional<Alliance> m_alliance;

    // The default speed of the CANdle LED animation
    private static final double c_defaultSpeed = 250;
    /**
     * The starting index on the robot's CAN bus LEDs for the CANdle. Not all CAN LEDs may
     * be part of the CANdle
     */
    private static final int c_ledStart = 8;
    /**
     * The ending index on the robot's CAN bus LEDs for the CANdle. Not all CAN LEDs may
     * be part of the CANdle
     */
    private static final int c_ledEnd = 24;

    // New default for animations is only initializing the start and ending index
    // start    The CAN bus LED identifier for the CANdle's first LED
    // end      The CAN bus LED identifier for the CANdle's last LED
    //
    // Information that needs to be configured later for Animations:
    // red, green, blue, white (brightness) [0 to 255]
    // speed	How fast should the color travel the strip [0, 1]
    //
    // Solid color
    private SolidColor m_solidColor = new SolidColor(c_ledStart, c_ledEnd);
    // Animation that gradually lights the entire LED strip one LED at a time
    // Additional args (to be configured later)
    // direction	Forward, Backward 
    private ColorFlowAnimation m_colorFlowAnimation = new ColorFlowAnimation(c_ledStart, c_ledEnd);
    // Animation that fades into and out of a specified color.
    private SingleFadeAnimation m_singleFadeAnimation = new SingleFadeAnimation(c_ledStart, c_ledEnd);
    // Animation that strobes the LEDs a specified color
    private StrobeAnimation m_strobeAnimation = new StrobeAnimation(c_ledStart, c_ledEnd);
    // Animation that sends a pocket of light across the LED strip (see https://en.wikipedia.org/wiki/Knight_Rider)
    // Additional args
    // BounceMode mode  Front, Center, Back; default Front
    // int size         Size of the group of lit LEDs [0 to 7]; defalt 2 
    // int ledOffset    Where to start the animation; default 0
    private LarsonAnimation m_larsonAnimation = new LarsonAnimation(c_ledStart, c_ledEnd);

    // Additional (previously unused) animations
    private TwinkleAnimation m_twinkleAnimation = new TwinkleAnimation(c_ledStart, c_ledEnd);
    private TwinkleOffAnimation m_twinkleOffAnimation = new TwinkleOffAnimation(c_ledStart, c_ledEnd);
    private RainbowAnimation m_rainbowAnimation = new RainbowAnimation(c_ledStart, c_ledEnd);
    private RgbFadeAnimation m_rgbFadeAnimation = new RgbFadeAnimation(c_ledStart, c_ledEnd);
    private FireAnimation m_fireAnimation = new FireAnimation(c_ledStart, c_ledEnd);


    // Magic number 0: Only the 0 animation slot is used (this replaces .ClearAnimation(0))
    private EmptyAnimation m_emptyAnimation = new EmptyAnimation(0);


    private RGBWColor m_defaultColor = c_defaultColor;
    private RGBWColor m_currentColor = c_colorBlack;
    private ECurrentAction m_currentAction;

    // Should be equivalent to framerate? phoenix speed -> phoenix6 FrameRate
    // From 1 to 500hz
    private double m_speed;
    private boolean m_bAllianceSet = false;
    // private boolean m_busy;

    private void setColor(RGBWColor color) {
        m_currentColor = color;
    }

    private boolean isSameColor(RGBWColor color1, RGBWColor color2) {
        return color1.equals(color2);
    }
}
